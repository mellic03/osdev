#pragma once

#include <stddef.h>
#include <stdint.h>


/*
    http://www.daubnet.com/en/file-format-bmp
*/
struct ck_BMP_infoheader
{
    uint32_t width;
    uint32_t height;
    uint16_t planes;
    uint16_t bpp;
    uint32_t compression;
    uint32_t imagesize;

    // Entire field can be set to 0 --> zero compression
    uint32_t ppm_x;             // pixels per meter.
    uint32_t ppm_y;             // pixels per meter.
    uint32_t colors_used;       // number of used colors.
    uint32_t colors_important;  // 0 == all
    uint8_t  color_table[4];    // present only if bpp <= 8

} __attribute__((packed));

struct ck_BMP_header
{
    uint16_t signature;
    uint32_t filesize;
    uint32_t reserved;
    uint32_t offset; // offset to image data

    uint32_t infosize; // should be sizeof(infoheader)
    ck_BMP_infoheader infoheader;

    void *data;
    /*
        pixels[0]
        ...
        pixels[bpp * imagesize]
    */
} __attribute__((packed));

// void test()
// {
//     sizeof(ck_BMP_infoheader);
// }



// unsigned char bmpData[] = // All values are little-endian
// {
//     0x42, 0x4D,             // Signature 'BM'
//     0xaa, 0x00, 0x00, 0x00, // Size: 170 bytes
//     0x00, 0x00,             // Unused
//     0x00, 0x00,             // Unused
//     0x8a, 0x00, 0x00, 0x00, // Offset to image data

//     0x7c, 0x00, 0x00, 0x00, // DIB header size (124 bytes)
//     0x04, 0x00, 0x00, 0x00, // Width (4px)
//     0x02, 0x00, 0x00, 0x00, // Height (2px)
//     0x01, 0x00,             // Planes (1)
//     0x20, 0x00,             // Bits per pixel (32)
//     0x03, 0x00, 0x00, 0x00, // Format (bitfield = use bitfields | no compression)
//     0x20, 0x00, 0x00, 0x00, // Image raw size (32 bytes)
//     0x13, 0x0B, 0x00, 0x00, // Horizontal print resolution (2835 = 72dpi * 39.3701)
//     0x13, 0x0B, 0x00, 0x00, // Vertical print resolution (2835 = 72dpi * 39.3701)
//     0x00, 0x00, 0x00, 0x00, // Colors in palette (none)
//     0x00, 0x00, 0x00, 0x00, // Important colors (0 = all)
//     0x00, 0x00, 0xFF, 0x00, // R bitmask (00FF0000)
//     0x00, 0xFF, 0x00, 0x00, // G bitmask (0000FF00)
//     0xFF, 0x00, 0x00, 0x00, // B bitmask (000000FF)
//     0x00, 0x00, 0x00, 0xFF, // A bitmask (FF000000)
//     0x42, 0x47, 0x52, 0x73, // sRGB color space
//     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused R, G, B entries for color space
//     0x00, 0x00, 0x00, 0x00, // Unused Gamma X entry for color space
//     0x00, 0x00, 0x00, 0x00, // Unused Gamma Y entry for color space
//     0x00, 0x00, 0x00, 0x00, // Unused Gamma Z entry for color space

//     0x00, 0x00, 0x00, 0x00, // Unknown
//     0x00, 0x00, 0x00, 0x00, // Unknown
//     0x00, 0x00, 0x00, 0x00, // Unknown
//     0x00, 0x00, 0x00, 0x00, // Unknown

//     // Image data:
//     0xFF, 0x00, 0x00, 0x7F, // Bottom left pixel
//     0x00, 0xFF, 0x00, 0x7F,
//     0x00, 0x00, 0xFF, 0x7F,
//     0xFF, 0xFF, 0xFF, 0x7F, // Bottom right pixel
//     0xFF, 0x00, 0x00, 0xFF, // Top left pixel
//     0x00, 0xFF, 0x00, 0xFF,
//     0x00, 0x00, 0xFF, 0xFF,
//     0xFF, 0xFF, 0xFF, 0xFF  // Top right pixel
// };
